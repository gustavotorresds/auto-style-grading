/*
 * File: Breakout.java
 * -------------------
 * Name: Miribel Tran
 * Section Leader: Julia Daniel
 * 
 * This GraphicsProgram generates a game that allows the user to play a game called "BreakOut."
 * The user is presented with a canvas with 10 rows of bricks of different colors of the rainbow, paddle that moves
 * in alignment with your mouse, and a ball in the center of the screen. When the user clicks, the ball will drop and move
 * at a random velocity generated by the program. The user needs to move the paddle so that that the ball lands on the paddle
 * and bounces up. Once it bounces up, it will bounce off the walls around until it eventually collides into a brick, which removes
 * it. The user will need to repeat the moving of the paddle to the ball in order to continue playing the game. If the ball isn't
 * able to bounce off the paddle, it will reach the bottom wall, causing the game to end. The user has three turns to "break out"
 * before the game terminates, and the user loses.
 */

import acm.graphics.*;
import acm.program.*;
import acm.util.*;

import java.applet.*;
import java.awt.*;
import java.awt.event.*;

public class Breakout extends GraphicsProgram {

	// Dimensions of the canvas, in pixels
	public static final double CANVAS_WIDTH = 420;
	public static final double CANVAS_HEIGHT = 600;

	// Number of bricks in each row
	public static final int NBRICK_COLUMNS = 10;

	// Number of rows of bricks
	public static final int NBRICK_ROWS = 10;

	// Separation between neighboring bricks, in pixels
	public static final double BRICK_SEP = 4;

	// Width of each brick, in pixels
	public static final double BRICK_WIDTH = Math.floor(
			(CANVAS_WIDTH - (NBRICK_COLUMNS + 1.0) * BRICK_SEP) / NBRICK_COLUMNS);

	// Height of each brick, in pixels
	public static final double BRICK_HEIGHT = 8;

	// Offset of the top brick row from the top, in pixels
	public static final double BRICK_Y_OFFSET = 70;

	// Dimensions of the paddle
	public static final double PADDLE_WIDTH = 60;
	public static final double PADDLE_HEIGHT = 10;

	// Offset of the paddle up from the bottom 
	public static final double PADDLE_Y_OFFSET = 30;

	// Radius of the ball in pixels
	public static final double BALL_RADIUS = 10;

	// The ball's vertical velocity.
	public static final double VELOCITY_Y = 3.0;

	// The ball's minimum and maximum horizontal velocity; the bounds of the
	// initial random velocity that you should choose (randomly +/-).
	public static final double VELOCITY_X_MIN = 1.0;
	public static final double VELOCITY_X_MAX = 3.0;

	// Animation delay or pause time between ball moves (ms)
	public static final double DELAY = 1000.0 / 60.0;

	// Number of turns 
	public static final int NTURNS = 3;

	//Where the boundary of the x value is on the left side
	public static final double STARTING_POINT_X = 0;

	//The object that follows the mouse and provides the surface for the ball to collide
	private GRect paddle;

	//Velocity of the ball
	private double vx, vy;

	//Randomly generates a number
	private RandomGenerator rgen = RandomGenerator.getInstance();

	//The ball that bounces
	private GOval ball;
	
	//Helps find y-coordinate to place endingTitle;
	private double labelTextY;
	
	//Helps find x-coordinates to place endingTitle
	private double labelTextX;
	
	//Tracks the number of bricks that are still available after all the ball bounces
	private int totalBricks = 100;
	

	public void run() {
		setTitle("CS 106A Breakout"); // Set the window's title bar text
		setCanvasSize(CANVAS_WIDTH, CANVAS_HEIGHT); // Set the canvas size
		createUpperBricks(); // Creates the rainbow rows of bricks
		addPaddle(); // Creates the paddle
		addMouseListeners(); // Tracks mouse movement
		ball = addBall(); // Adds a ball to the center of the screen
		waitForClick(); // User must click on the ball for the game to start
		getOriginalVelocity(); // Records the velocity
		int LivesLeft = 3; // Keeps track of the number of turns
		while((totalBricks > 0) && (ball != null) && LivesLeft > 0) {
			ballMoved();
			if (ball != null) { // If the ball bounces onto a paddle
				getCollidingObject();
				bounceBack();
			}
			if (ball == null) { // If the ball hits the bottom wall
				ball = addBall(); //its taken away, now we have to recreate it
				waitForClick();
				getOriginalVelocity();
				LivesLeft--;
			}
			
		}
		if (totalBricks == 0) { // If the user has removed all the bricks, game terminates and send labels indicating victory
			addLabelWinner();
		}
		else {
			addLabelLoser();	// When the user has used up all the turns, game terminates and sends label indicating loss
		}
	}
	
	
	/**
	 * Method: Add Loser Ending Title
	 * -----------------------
	 * When the user loses, it will display this ending title and the game terminates.
	 */
	private void addLabelLoser() {
		GLabel endingTitle = new GLabel("You lose :(");
		endingTitle.setFont("SansSerif-18");
		labelTextX = endingTitle.getWidth();
		labelTextY = endingTitle.getHeight() + 2*(endingTitle.getAscent());
		endingTitle.setLocation(getWidth()/2 + labelTextX, getHeight()/2 + labelTextY);
		add(endingTitle);
	}

	/**
	 * Method: Add Winner Ending Title
	 * -----------------------
	 * Adds a winning title when all the bricks have been eliminated
	 */
	private void addLabelWinner() {
		/* This method adds the "CS106A" text in the middle of the rectangle. */
		GLabel endingTitle = new GLabel("BREAKOUT! You win!");
		labelTextX = endingTitle.getWidth();
		labelTextY = endingTitle.getHeight() + 2*(endingTitle.getAscent());
		endingTitle.setFont("SansSerif-18");
		endingTitle.setLocation(getWidth()/2, getHeight()/2);
		add(endingTitle);
	}
	
	/**
	 * Method: Determines appropriate response 
	 * -----------------------
	 * The ball will either collide with a brick or paddle. This method determines its response, either it
	 * only bounce ups or it take away brick(s) and bounces downwards)
	 */
	private void bounceBack() {  
		GObject collider = getCollidingObject();
		if (collider == paddle) { // The ball will bounce up from the paddle.
			vy = (-1)*Math.abs(vy);
		}
		else if (collider != null) { // The ball will take away one brick and bounce back.
			remove(collider); 
			totalBricks--;
			vy = (-1)*vy;
		}
	}

	/**
	 * Method: Check if it's colliding with an object
	 * -----------------------
	 * This checks at a specific location if the ball is colliding with an object.
	 */
	private GObject getCollidingObject() {
		double ballX = ball.getX();
		double ballY = ball.getY();
		if (getElementAt(ballX, ballY) != null) { 
			return(getElementAt(ballX, ballY)); //top left
		} 
		else if (getElementAt(ballX, ballY + 2*(BALL_RADIUS)) != null) {
			return(getElementAt(ballX, ballY + 2*(BALL_RADIUS))); //bottom left
		}
		else if (getElementAt(ballX + 2*(BALL_RADIUS), ballY) != null){
			return(getElementAt(ballX + 2*(BALL_RADIUS), ballY)); //top right
		}
		else if (getElementAt(ballX + 2*(BALL_RADIUS), ballY + 2*(BALL_RADIUS)) != null){
			return(getElementAt(ballX + 2*(BALL_RADIUS), ballY + 2*(BALL_RADIUS))); //bottom right
		}
		return(null);
	}

	/**
	 * Method: Make ball move
	 * -----------------------
	 * This makes the ball move.
	 */
	private void ballMoved() {
		ball.move(vx, vy);
		pause(DELAY);
		ballBounce();

	}

	/**
	 * Method: Make ball bounce off of walls
	 * -----------------------
	 * Makes the ball bounce off of walls and go in the opposite direction
	 */
	private void ballBounce() {
		if(hitLeftWall(ball) || hitRightWall(ball)) {
			vx = -vx;
		}
		if(hitTopWall(ball)) {
			vy = -vy; ////fix
		}
		if(hitBottomWall(ball) ) {
			remove(ball);
			ball = null;
		}
	}

	/**
	 * Method: Hit Bottom Wall
	 * -----------------------
	 * Returns whether or not the given ball should bounce off
	 * of the bottom wall of the window.
	 */
	private boolean hitBottomWall(GOval ball) {
		return ball.getY() > getHeight() - ball.getHeight();
	}

	/**
	 * Method: Hit Top Wall
	 * -----------------------
	 * Returns whether or not the given ball should bounce off
	 * of the top wall of the window.
	 */
	private boolean hitTopWall(GOval ball) {
		return ball.getY() <= 0;
	}

	/**
	 * Method: Hit Right Wall
	 * -----------------------
	 * Returns whether or not the given ball should bounce off
	 * of the right wall of the window.
	 */
	private boolean hitRightWall(GOval ball) {
		return ball.getX() >= getWidth() - ball.getWidth();
	}

	/**
	 * Method: Hit Left Wall
	 * -----------------------
	 * Returns whether or not the given ball should bounce off
	 * of the left wall of the window.
	 */
	private boolean hitLeftWall(GOval ball) {
		return ball.getX() <= 0;
	}

	/**
	 * Method: Generates a velocity
	 * -----------------------
	 * This method generates a random original velocity for the ball to move at.
	 */
	private void getOriginalVelocity() {
		vx = rgen.nextDouble(VELOCITY_X_MIN, VELOCITY_X_MAX);
		if (rgen.nextBoolean(0.5)) vx = -vx;
		vy = rgen.nextDouble(VELOCITY_X_MIN, VELOCITY_X_MAX);
	}

	/**
	 * Method: Track mouse movements
	 * -----------------------
	 * This tracks the mouse movements and adjusts the paddle's location according to the mouse movements.
	 */
	public void mouseMoved(MouseEvent e) {
		if ((e.getX() < getWidth() - PADDLE_WIDTH) &&  (e.getX() > STARTING_POINT_X)) {
			double  x = e.getX();
			double y = getHeight() - PADDLE_Y_OFFSET;
			paddle.setLocation(x, y);
		}
	}

	/**
	 * Method: Add ball
	 * -----------------------
	 * This method adds a ball in the center of the screen.
	 */
	private GOval addBall() {
		double size = BALL_RADIUS * 2;
		ball = new GOval(getWidth()/2, getHeight()/2, size, size); 
		ball.setFilled(true);
		ball.setColor(Color.BLACK);
		add(ball);
		return(ball);
	}

	/**
	 * Method: Add paddle
	 * -----------------------
	 * This method adds a paddle that follows the mouse's movements.
	 */
	private void addPaddle() {
		paddle = new GRect(getWidth()*0.5 - PADDLE_WIDTH/2, getHeight() - PADDLE_Y_OFFSET, PADDLE_WIDTH, PADDLE_HEIGHT);
		paddle.setFilled(true);
		paddle.setColor(Color.BLACK);
		add(paddle);
	}

	/**
	 * Method: Create multiple rows of bricks
	 * -----------------------
	 * This method is in charge of creating several rows of bricks.
	 */
	private void createUpperBricks() {
		for (int rowNumber = 0; rowNumber < 10; rowNumber++) {
			double y = BRICK_SEP*rowNumber + BRICK_HEIGHT*rowNumber;
			drawRow(y, rowNumber);
		}
	}

	/**
	 * Method: Add 1 entire row of bricks.
	 * -----------------------
	 * This method creates an entire row of bricks.
	 */
	private void drawRow(double y, int rowNumber) {
		double x = 0 + BRICK_SEP;
		for (int currentBrickNum = 0; currentBrickNum < NBRICK_COLUMNS; currentBrickNum++) {
			drawBrick(x + (currentBrickNum + 1)*BRICK_SEP + currentBrickNum*(BRICK_WIDTH), y + BRICK_SEP + BRICK_HEIGHT, rowNumber);
		}
	}

	/**
	 * Method: Add brick
	 * -----------------------
	 * This method creates an individual brick and changes the color according to its row number.
	 */
	private void drawBrick(double x, double y, int rowNumber) {
		GRect rect = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);
		rect.setFilled(true);
		if (rowNumber < 2) {
			rect.setColor(Color.RED);
		}
		else if (rowNumber < 4) {
			rect.setColor(Color.ORANGE);
		}
		else if (rowNumber < 6) {
			rect.setColor(Color.YELLOW);
		}
		else if (rowNumber < 8) {
			rect.setColor(Color.GREEN);
		}
		else if (rowNumber <10) {
			rect.setColor(Color.CYAN);
		}
		add(rect);
	}
}